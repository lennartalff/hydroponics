#!/usr/bin/env python3

import collections
import serial
import rospy
from std_msgs.msg import Empty, Bool
import threading
from avrhydroponics import pkt


class Node(object):
    def __init__(self):
        rospy.init_node("transmitter_node")
        self.port = self.get_serial_port()
        self.data_lock = threading.RLock()

        self.ready_flag = False

        self.user_packets = collections.deque([], 10)

        measure_packets = [
            pkt.encode_cmd_owi_measure(),
            pkt.encode_cmd_ec_measure(),
            pkt.encode_cmd_ph_measure()
        ]

        self.measure_packets = collections.deque(measure_packets,
                                                 len(measure_packets))
        self.measure_packet_counter = 0

        self.sensor_cycle_complete_publisher = rospy.Publisher(
            "sensor_cycle_complete", Empty)

        rospy.Subscriber("receive_timeout", Empty, self.on_receive_timeout)
        rospy.Subscriber("ready_state", Bool, self.on_ready_state)

    def on_ready_state(self, msg):
        if not msg.data:
            self.ready_flag = False
            return
        with self.data_lock:
            packet_to_send = None
            try:
                packet_to_send = self.user_packets.popleft()
            except IndexError:
                packet_to_send = self.measure_packets[0]
                self.measure_packets.rotate()
                self.measure_packet_counter += 1
                if self.measure_packet_counter >= len(self.measure_packets):
                    self.measure_packet_counter = 0
                    self.sensor_cycle_complete_publisher.publish(Empty())
            finally:
                self._send_packet(packet_to_send)

    def get_serial_port(self):
        port = rospy.get_param("serial_port")
        timeout = float(rospy.get_param("serial_timeout"))
        baud = int(rospy.get_param("serial_baud"))
        rospy.loginfo("[%s] Connecting on port %s with baud %d and timeout %d",
                      rospy.get_name(), port, baud, timeout)
        return serial.Serial(port=port, baudrate=baud, timeout=timeout)

    def _send_packet(self, packet):
        data = pkt.packet_serialize(packet)
        encoded_data = pkt.cobs_encode(data)
        self.port.write(bytearray(encoded_data))
        self.ready_flag = False

    def on_receive_timeout(self, msg):
        # quite normal that no data could be received if device is in ready state
        if self.ready_flag:
            return

        # request a ready response. in normal operation this should not be
        # necessary because the microcontroller sends a ready signal by itself
        # after each operation.
        packet = pkt.encode_ready_request()
        self._send_packet(packet)


def main():
    node = Node()
    rospy.spin()


if __name__ == "__main__":
    main()